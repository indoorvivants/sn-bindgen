<html><head><title>SN bindgen: Semantics </title><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/androidstudio.min.css" /><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/languages/scala.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/languages/c.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="/assets/styles.css" /><link rel="stylesheet" href="/assets/template.css" /><script src="/assets/search.js"></script><script src="/assets/search-index.js"></script><link rel="stylesheet" href="/assets/subatomic-search.css" /><meta charset="UTF-8" /></head><body><div class="container"><header class="main-header"><div class="site-title"><h1><a href="/">SN bindgen</a></h1><small>Scala 3 Native binding generator to C libraries</small></div><div id="searchContainer" class="searchContainer"></div><div class="site-links"><a href="https://github.com/indoorvivants/sn-bindgen"><img src="https://cdn.svgporn.com/logos/github-icon.svg" class="gh-logo" /></a></div></header><div><a class="nav-btn" href="/index.html">Home</a><a class="nav-btn" href="/configuration/index.html">Configuration </a><a class="nav-btn" href="/limitations/index.html">Limitations</a><a class="nav-btn" href="/motivation/index.html">Motivation</a><a class="nav-btn" href="/quickstart/index.html">Quick start</a><a class="nav-btn nav-selected" href="/semantics/index.html">Semantics </a></div><hr /><div><h3><a href="#structs-are-converted-to-opaque-types" id="structs-are-converted-to-opaque-types">Structs are converted to opaque types</a></h3>
<p>For those types, we generate getters, setters, <code>Tag</code> definition, and two constructors, with and without parameters, allocating the struct on the heap.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />    typedef struct {<br />      long long number;<br />    } Small;<br />    <br />    typedef struct {<br />      int x;<br />      char* hello;<br />      Small sm;<br />    } Big;<br />    </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object types:<br>  opaque type Big = CStruct3[CInt, CString, Small]<br>  object Big:<br>    given _tag: Tag[Big] = Tag.materializeCStruct3Tag[CInt, CString, Small]<br>    def apply()(using Zone): Ptr[Big] = scala.scalanative.unsafe.alloc[Big](1)<br>    def apply(x: CInt, hello: CString, sm: Small)(using Zone): Ptr[Big] = <br>      val ____ptr = apply()<br>      (!____ptr).x = x<br>      (!____ptr).hello = hello<br>      (!____ptr).sm = sm<br>      ____ptr<br>    extension (struct: Big)<br>      def x: CInt = struct._1<br>      def x_=(value: CInt): Unit = !struct.at1 = value<br>      def hello: CString = struct._2<br>      def hello_=(value: CString): Unit = !struct.at2 = value<br>      def sm: Small = struct._3<br>      def sm_=(value: Small): Unit = !struct.at3 = value<br><br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number: CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number: CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br></code></pre></div></div></div></div>
<h3><a href="#unions-are-converted-to-opaque-types" id="unions-are-converted-to-opaque-types">Unions are converted to opaque types</a></h3>
<p>For a union with <code>N</code> members, <code>N</code> constructors will be generated,
along with getters and setters.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />      typedef struct {<br />        long long number;<br />      } Small;<br />      <br />      typedef union {<br />        int x;<br />        char* hello;<br />        Small sm;<br />      } Big;<br />      </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object types:<br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number: CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number: CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br>  opaque type Big = CArray[Byte, Nat._8]<br>  object Big:<br>    given _tag: Tag[Big] = Tag.CArray[CChar, Nat._8](Tag.Byte, Tag.Nat8)<br>    def apply()(using Zone): Ptr[Big] = <br>      val ___ptr = alloc[Big](1)<br>      ___ptr<br>    @scala.annotation.targetName("apply_x")<br>    def apply(x: CInt)(using Zone): Ptr[Big] =<br>      val ___ptr = alloc[Big](1)<br>      val un = !___ptr<br>      un.at(0).asInstanceOf[Ptr[CInt]].update(0, x)<br>      ___ptr<br>    @scala.annotation.targetName("apply_hello")<br>    def apply(hello: CString)(using Zone): Ptr[Big] =<br>      val ___ptr = alloc[Big](1)<br>      val un = !___ptr<br>      un.at(0).asInstanceOf[Ptr[CString]].update(0, hello)<br>      ___ptr<br>    @scala.annotation.targetName("apply_sm")<br>    def apply(sm: Small)(using Zone): Ptr[Big] =<br>      val ___ptr = alloc[Big](1)<br>      val un = !___ptr<br>      un.at(0).asInstanceOf[Ptr[Small]].update(0, sm)<br>      ___ptr<br>    extension (struct: Big)<br>      def x: CInt = !struct.at(0).asInstanceOf[Ptr[CInt]]<br>      def x_=(value: CInt): Unit = !struct.at(0).asInstanceOf[Ptr[CInt]] = value<br>      def hello: CString = !struct.at(0).asInstanceOf[Ptr[CString]]<br>      def hello_=(value: CString): Unit = !struct.at(0).asInstanceOf[Ptr[CString]] = value<br>      def sm: Small = !struct.at(0).asInstanceOf[Ptr[Small]]<br>      def sm_=(value: Small): Unit = !struct.at(0).asInstanceOf[Ptr[Small]] = value<br><br></code></pre></div></div></div></div>
<h3><a href="#simple-functions-are-converted-to-direct-extern-functions" id="simple-functions-are-converted-to-direct-extern-functions">Simple functions are converted to direct <code>@extern</code> functions</a></h3>
<p>Where &quot;Simple&quot; means &quot;not passing naked <code>structs</code>&quot;, because Scala Native cannot handle that (passing by pointer is okay)</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />        typedef struct {<br />          long long number;<br />        } Small;<br />        <br />        long simple(int x, char *y);<br />        Small* with_pointers(Small *x, int y);<br />        </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object types:<br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number: CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number: CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br>@extern<br>private[libtest] object extern_functions:<br>  import types.*<br>  def simple(x: CInt, y: CString): CLongInt = extern<br><br>  def with_pointers(x: Ptr[Small], y: CInt): Ptr[Small] = extern<br><br>object functions:<br>  import types.*<br>  import extern_functions.*<br>  export extern_functions.*<br><br></code></pre></div></div></div></div>
<h3><a href="#problematic-functions-generate-c-forwarders" id="problematic-functions-generate-c-forwarders">Problematic functions generate C forwarders</a></h3>
<p>Where &quot;Problematic&quot; means having a struct as one of its arguments or return type.
In this case we generate several variations of public Scala functions,
but they all delegate to an external C function which takes its arguments as <strong>pointers</strong>, and (optionally) returns its value in a provided heap-allocated location.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />          typedef struct {<br />            long long number;<br />          } Small;<br />          <br />          void bad_arguments(Small n, Small n2);<br />          Small bad_return_type();<br />          </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object types:<br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number: CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number: CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br>@extern<br>private[libtest] object extern_functions:<br>  import types.*<br>  private[libtest] def __sn_wrap_libtest_bad_arguments(n: Ptr[Small], n2: Ptr[Small]): Unit = extern<br><br>  private[libtest] def __sn_wrap_libtest_bad_return_type(__return: Ptr[Small]): Unit = extern<br><br>object functions:<br>  import types.*<br>  import extern_functions.*<br>  export extern_functions.*<br>  def bad_arguments(n: Ptr[Small], n2: Ptr[Small]): Unit = <br>    __sn_wrap_libtest_bad_arguments(n, n2)<br><br>  def bad_arguments(n: Small, n2: Small)(using Zone): Unit = <br>    val __ptr_0: Ptr[Small] = alloc[Small](2)<br>    !(__ptr_0 + 0) = n<br>    !(__ptr_0 + 1) = n2<br>    __sn_wrap_libtest_bad_arguments((__ptr_0 + 0), (__ptr_0 + 1))<br><br>  def bad_return_type()(using Zone): Small = <br>    val __ptr_0: Ptr[Small] = alloc[Small](1)<br>    __sn_wrap_libtest_bad_return_type((__ptr_0 + 0))<br>    !(__ptr_0 + 0)<br><br>  def bad_return_type()(__return: Ptr[Small]): Unit = <br>    __sn_wrap_libtest_bad_return_type(__return)<br><br></code></pre></div></div><div style = "overflow: scroll;"><b>Generated C</b><div style = "max-height:400px"><pre><code class = "hljs">&#35;include &lt;string.h&gt;<br><br>void __sn_wrap_libtest_bad_arguments(Small *n, Small *n2) {<br> bad_arguments(*n, *n2);<br>};<br><br><br>void __sn_wrap_libtest_bad_return_type(Small *____return) {<br>  Small ____ret = bad_return_type();<br>  memcpy(____return, &____ret, sizeof(Small));<br>}<br><br><br></code></pre></div></div></div></div>
<h3><a href="#enums-are-generated-for-specific-c-type" id="enums-are-generated-for-specific-c-type">Enums are generated for specific C type</a></h3>
<p>Whatever type clang reports for a particular enum - that's the type that will be
used for the enum.</p>
<p>This is important, as on Windows enums are <code>int</code> by default, whereas on Linux and OS X they are <code>unsigned int</code> (if there's no negative elements).</p>
<p>This documentation is built on Linux.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />            typedef enum {<br />              U_X = 1,<br />              U_Y = 4,<br />              U_Z = 228<br />            } MyUnsigned;<br />            <br />            typedef enum {<br />              X = -1,<br />              Y = 4,<br />              Z = 228<br />            } MySigned;<br />            </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object predef:<br>  <br>  trait CEnum[T](using eq: T =:= Int):<br>    given Tag[T] = Tag.Int.asInstanceOf[Tag[T]]<br>    extension (t: T) def int: CInt = eq.apply(t)<br>       <br>  <br>  trait CEnumU[T](using eq: T =:= UInt):<br>    given Tag[T] = Tag.UInt.asInstanceOf[Tag[T]]<br>    extension (t: T)<br>     def int: CInt = eq.apply(t).toInt<br>     def uint: CUnsignedInt = eq.apply(t)<br>        <br>object types:<br>  import predef.*<br>  opaque type MySigned = CInt<br>  object MySigned extends CEnum[MySigned]:<br>    given _tag: Tag[MySigned] = Tag.Int<br>    inline def define(inline a: CInt): MySigned = a<br>    val X = define(-1)<br>    val Y = define(4)<br>    val Z = define(228)<br>    extension (a: MySigned)<br>      inline def &(b: MySigned): MySigned = a & b<br>      inline def |(b: MySigned): MySigned = a | b<br>      inline def is(b: MySigned): Boolean = (a & b) == b<br><br>  opaque type MyUnsigned = CUnsignedInt<br>  object MyUnsigned extends CEnumU[MyUnsigned]:<br>    given _tag: Tag[MyUnsigned] = Tag.UInt<br>    inline def define(inline a: Long): MyUnsigned = a.toUInt<br>    val U_X = define(1)<br>    val U_Y = define(4)<br>    val U_Z = define(228)<br>    extension (a: MyUnsigned)<br>      inline def &(b: MyUnsigned): MyUnsigned = a & b<br>      inline def |(b: MyUnsigned): MyUnsigned = a | b<br>      inline def is(b: MyUnsigned): Boolean = (a & b) == b<br><br></code></pre></div></div></div></div>
<h3><a href="#function-pointers-are-defined-as-opaque-types" id="function-pointers-are-defined-as-opaque-types">Function pointers are defined as opaque types</a></h3>
<p>The inlining in <code>apply</code> method is important - it's a restricting of Scala Native
that the function must be statically known.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />              typedef void* Cursor;<br />              typedef int (*Visitor)(Cursor*);<br />              </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object types:<br>  opaque type Cursor = Ptr[Byte]<br>  object Cursor: <br>    given _tag: Tag[Cursor] = Tag.Ptr(Tag.Byte)<br>    inline def apply(inline o: Ptr[Byte]): Cursor = o<br><br>  opaque type Visitor = CFuncPtr1[Ptr[Cursor], CInt]<br>  object Visitor: <br>    given _tag: Tag[Visitor] = Tag.materializeCFuncPtr1[Ptr[Cursor], CInt]<br>    inline def apply(inline o: CFuncPtr1[Ptr[Cursor], CInt]): Visitor = o<br><br></code></pre></div></div></div></div>
<h3><a href="#recursive-structs-are-rewritten-with-opaque-pointers" id="recursive-structs-are-rewritten-with-opaque-pointers">Recursive structs are rewritten with opaque pointers</a></h3>
<p>This is invisible to the user, so doesn't impact the experience, but
can complicate reading the code.</p>
<p>Scala cannot have recursive type aliases.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C header</b><pre><code class = "hljs language-c"><br />                typedef struct Arr;<br />                <br />                typedef struct {<br />                  struct Arr* nested;<br />                } Arr;<br />                </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import scala.scalanative.unsafe.*<br>import scala.scalanative.unsigned.*<br>import scalanative.libc.*<br><br>object types:<br>  opaque type Arr = CStruct1[Ptr[Byte]]<br>  object Arr:<br>    given _tag: Tag[Arr] = Tag.materializeCStruct1Tag[Ptr[Byte]]<br>    def apply()(using Zone): Ptr[Arr] = scala.scalanative.unsafe.alloc[Arr](1)<br>    def apply(nested: Ptr[Arr])(using Zone): Ptr[Arr] = <br>      val ____ptr = apply()<br>      (!____ptr).nested = nested<br>      ____ptr<br>    extension (struct: Arr)<br>      def nested: Ptr[Arr] = struct._1.asInstanceOf[Ptr[Arr]]<br>      def nested_=(value: Ptr[Arr]): Unit = !struct.at1 = value.asInstanceOf[Ptr[Byte]]<br><br></code></pre></div></div></div></div>
</div></div><footer>Â© 2021-2022 Anton Sviridov</footer><script src="https://www.googletagmanager.com/gtag/js?id=G-2V7BY56Z37"></script><script> window.dataLayer = window.dataLayer || [];
              function gtag(){window.dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-2V7BY56Z37');</script></body></html>