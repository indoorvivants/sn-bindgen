<html><head><title>SN bindgen: Semantics </title><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/tomorrow-night-blue.min.css" /><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/scala.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/c.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="/assets/styles.css" /><link rel="stylesheet" href="/assets/tailwind.css" /><script src="/assets/search.js" defer="defer"></script><script src="/assets/search-index.js" defer="defer"></script><link rel="stylesheet" href="/assets/subatomic-search.css" /><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /></head><body onclick="SubatomicSearchFrontend.sayHello()" class="bg-gradient-to-r from-emerald-800 to-sky-700 mt-4 w-full"><header class="flex m-2 mb-4 md:m-auto md:w-11/12 lg:max-w-7xl flex-col md:flex-row md:items-center justify-between mb-2"><div><a class="block text-6xl text-white" href="/">SN bindgen</a><p class="text-white">Scala 3 Native binding generator to C libraries</p></div><div id="searchContainer"></div><div class="site-links"><a href="https://github.com/indoorvivants/sn-bindgen"><img class="w-12 opacity-70 hover:opacity-100" src="https://cdn.svgporn.com/logos/github-icon.svg" /></a></div></header><main class="rounded-xl bg-white m-2 mb-4 md:m-auto md:w-11/12 lg:max-w-7xl p-4 flex flex-col-reverse md:flex-row gap-6"><aside class="lg:w-64 shrink-1 lg:shrink-0 grow-0 md:border-r-2 max-w-[300px] border-slate-200 pr-2"><ul class="text-2xl p-4 block"><li><a class="" href="/index.html">Home</a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/cookbook/index.html">Cookbook</a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/configuration/index.html">Configuration </a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/limitations/index.html">Limitations</a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/exports/index.html">Exports </a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/motivation/index.html">Motivation</a><ul class="text-xl p-2 block"></ul></li><li><a class="font-bold" href="/semantics/index.html">Semantics </a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/quickstart/index.html">Quick start</a><ul class="text-xl p-2 block"></ul></li></ul></aside><article class="grow-4 lg:max-w-6xl markdown"><div class="float-right p-3 rounded-md border-2 border-sky-700 max-w-12 m-4"><ul class="list-disc my-0 mx-2 text-sm"><li><a class="underline hover:no-underline text-sky-700 text-base" href="#structs-are-converted-to-opaque-types">Structs are converted to opaque types</a><ul class="list-disc my-0 mx-2 text-sm"><li><a class="underline hover:no-underline text-sky-700 text-base" href="#you-can-disable-constructor-generation">You can disable constructor generation</a></li></ul></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#unions-are-converted-to-opaque-types">Unions are converted to opaque types</a><ul class="list-disc my-0 mx-2 text-sm"><li><a class="underline hover:no-underline text-sky-700 text-base" href="#simple-functions-are-converted-to-direct-extern-functions">Simple functions are converted to direct `@extern` functions</a></li></ul></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#problematic-functions-generate-c-forwarders">Problematic functions generate C forwarders</a></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#enums-are-generated-for-specific-c-type">Enums are generated for specific C type</a></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#function-pointers-are-defined-as-opaque-types">Function pointers are defined as opaque types</a></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#recursive-structs-are-rewritten-with-opaque-pointers">Recursive structs are rewritten with opaque pointers</a></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#global-enums-are-rendered-as-constants">Global enums are rendered as constants</a></li></ul></div><div><h2><a href="#structs-are-converted-to-opaque-types" id="structs-are-converted-to-opaque-types">Structs are converted to opaque types</a></h2>
<p>For those types, we generate getters, setters, <code>Tag</code> definition, and two <code>apply</code> methods:</p>
<ol>
<li>A constructor, which takes all the parameters as arguments</li>
<li>An allocator, which only creates an instance on the heap, without initialising it</li>
</ol>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct {
  long long number;
} Small;

typedef struct {
  int x;
  char* hello;
  Small sm;
} Big;
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/7847373246051599140header.h
  */
  opaque type Big = CStruct3[CInt, CString, Small]
  object Big:
    given _tag: Tag[Big] = Tag.materializeCStruct3Tag[CInt, CString, Small]
    def apply()(using Zone): Ptr[Big] = scala.scalanative.unsafe.alloc[Big](1)
    def apply(x : CInt, hello : CString, sm : Small)(using Zone): Ptr[Big] = 
      val ____ptr = apply()
      (!____ptr).x = x
      (!____ptr).hello = hello
      (!____ptr).sm = sm
      ____ptr
    extension (struct: Big)
      def x : CInt = struct._1
      def x_=(value: CInt): Unit = !struct.at1 = value
      def hello : CString = struct._2
      def hello_=(value: CString): Unit = !struct.at2 = value
      def sm : Small = struct._3
      def sm_=(value: Small): Unit = !struct.at3 = value

  /**
   * [bindgen] header: /tmp/7847373246051599140header.h
  */
  opaque type Small = CStruct1[CLongLong]
  object Small:
    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]
    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)
    def apply(number : CLongLong)(using Zone): Ptr[Small] = 
      val ____ptr = apply()
      (!____ptr).number = number
      ____ptr
    extension (struct: Small)
      def number : CLongLong = struct._1
      def number_=(value: CLongLong): Unit = !struct.at1 = value

object types:
  export _root_.libtest.structs.*

object all:
  export _root_.libtest.structs.Big
  export _root_.libtest.structs.Small


</code></pre>
</div>
</div>
<h3><a href="#you-can-disable-constructor-generation" id="you-can-disable-constructor-generation">You can disable constructor generation</a></h3>
<p>Some bindings (libnotify, gtk, nuklear) have such deep type hierarchies, that apply methods
on some structs trigger an exception during bytecode generation (when compiling the generated
code):</p>
<pre><code>java.lang.IllegalArgumentException: UTF8 string too large
</code></pre>
<p>To work around it, you can disable constructor generation by passing a comma-separated
list of struct names using the <code>--render.no-constructor</code> option in CLI, and <code>noConstructor</code>
parameter in the <code>Binding(...)</code> specification.</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct {
  int x;
  char* hello;
} Enabled;

typedef struct {
  int x;
  char* hello;
} Disabled;
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/13084187253627059224header.h
  */
  opaque type Disabled = CStruct2[CInt, CString]
  object Disabled:
    given _tag: Tag[Disabled] = Tag.materializeCStruct2Tag[CInt, CString]
    def apply()(using Zone): Ptr[Disabled] = scala.scalanative.unsafe.alloc[Disabled](1)
    extension (struct: Disabled)
      def x : CInt = struct._1
      def x_=(value: CInt): Unit = !struct.at1 = value
      def hello : CString = struct._2
      def hello_=(value: CString): Unit = !struct.at2 = value

  /**
   * [bindgen] header: /tmp/13084187253627059224header.h
  */
  opaque type Enabled = CStruct2[CInt, CString]
  object Enabled:
    given _tag: Tag[Enabled] = Tag.materializeCStruct2Tag[CInt, CString]
    def apply()(using Zone): Ptr[Enabled] = scala.scalanative.unsafe.alloc[Enabled](1)
    def apply(x : CInt, hello : CString)(using Zone): Ptr[Enabled] = 
      val ____ptr = apply()
      (!____ptr).x = x
      (!____ptr).hello = hello
      ____ptr
    extension (struct: Enabled)
      def x : CInt = struct._1
      def x_=(value: CInt): Unit = !struct.at1 = value
      def hello : CString = struct._2
      def hello_=(value: CString): Unit = !struct.at2 = value

object types:
  export _root_.libtest.structs.*

object all:
  export _root_.libtest.structs.Disabled
  export _root_.libtest.structs.Enabled


</code></pre>
</div>
</div>
<h2><a href="#unions-are-converted-to-opaque-types" id="unions-are-converted-to-opaque-types">Unions are converted to opaque types</a></h2>
<p>For a union with <code>N</code> members, <code>N</code> constructors will be generated,
along with getters and setters.</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct {
  long long number;
} Small;

typedef union {
  int x;
  char* hello;
  Small sm;
} Big;
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  import _root_.libtest.unions.*
  /**
   * [bindgen] header: /tmp/7695830449550333256header.h
  */
  opaque type Small = CStruct1[CLongLong]
  object Small:
    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]
    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)
    def apply(number : CLongLong)(using Zone): Ptr[Small] = 
      val ____ptr = apply()
      (!____ptr).number = number
      ____ptr
    extension (struct: Small)
      def number : CLongLong = struct._1
      def number_=(value: CLongLong): Unit = !struct.at1 = value

object unions:
  import _root_.libtest.structs.*
  import _root_.libtest.unions.*
  /**
   * [bindgen] header: /tmp/7695830449550333256header.h
  */
  opaque type Big = CArray[Byte, Nat._8]
  object Big:
    given _tag: Tag[Big] = Tag.CArray[CChar, Nat._8](Tag.Byte, Tag.Nat8)
    def apply()(using Zone): Ptr[Big] = 
      val ___ptr = alloc[Big](1)
      ___ptr
    @scala.annotation.targetName(&quot;apply_x&quot;)
    def apply(x: CInt)(using Zone): Ptr[Big] =
      val ___ptr = alloc[Big](1)
      val un = !___ptr
      un.at(0).asInstanceOf[Ptr[CInt]].update(0, x)
      ___ptr
    @scala.annotation.targetName(&quot;apply_hello&quot;)
    def apply(hello: CString)(using Zone): Ptr[Big] =
      val ___ptr = alloc[Big](1)
      val un = !___ptr
      un.at(0).asInstanceOf[Ptr[CString]].update(0, hello)
      ___ptr
    @scala.annotation.targetName(&quot;apply_sm&quot;)
    def apply(sm: Small)(using Zone): Ptr[Big] =
      val ___ptr = alloc[Big](1)
      val un = !___ptr
      un.at(0).asInstanceOf[Ptr[Small]].update(0, sm)
      ___ptr
    extension (struct: Big)
      def x : CInt = !struct.at(0).asInstanceOf[Ptr[CInt]]
      def x_=(value: CInt): Unit = !struct.at(0).asInstanceOf[Ptr[CInt]] = value
      def hello : CString = !struct.at(0).asInstanceOf[Ptr[CString]]
      def hello_=(value: CString): Unit = !struct.at(0).asInstanceOf[Ptr[CString]] = value
      def sm : Small = !struct.at(0).asInstanceOf[Ptr[Small]]
      def sm_=(value: Small): Unit = !struct.at(0).asInstanceOf[Ptr[Small]] = value

object types:
  export _root_.libtest.structs.*
  export _root_.libtest.unions.*

object all:
  export _root_.libtest.structs.Small
  export _root_.libtest.unions.Big


</code></pre>
</div>
</div>
<h3><a href="#simple-functions-are-converted-to-direct-extern-functions" id="simple-functions-are-converted-to-direct-extern-functions">Simple functions are converted to direct <code>@extern</code> functions</a></h3>
<p>Where &quot;Simple&quot; means &quot;not passing naked <code>structs</code>&quot;, because Scala Native cannot handle that (passing by pointer is okay)</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct {
  long long number;
} Small;

long simple(int x, char *y);
Small* with_pointers(Small *x, int y);
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/2280573422366889423header.h
  */
  opaque type Small = CStruct1[CLongLong]
  object Small:
    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]
    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)
    def apply(number : CLongLong)(using Zone): Ptr[Small] = 
      val ____ptr = apply()
      (!____ptr).number = number
      ____ptr
    extension (struct: Small)
      def number : CLongLong = struct._1
      def number_=(value: CLongLong): Unit = !struct.at1 = value


@extern
private[libtest] object extern_functions:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/2280573422366889423header.h
  */
  def simple(x : CInt, y : CString): CLongInt = extern

  /**
   * [bindgen] header: /tmp/2280573422366889423header.h
  */
  def with_pointers(x : Ptr[Small], y : CInt): Ptr[Small] = extern


object functions:
  import _root_.libtest.structs.*
  import extern_functions.*
  export extern_functions.*

object types:
  export _root_.libtest.structs.*

object all:
  export _root_.libtest.structs.Small
  export _root_.libtest.functions.simple
  export _root_.libtest.functions.with_pointers


</code></pre>
</div>
</div>
<h2><a href="#problematic-functions-generate-c-forwarders" id="problematic-functions-generate-c-forwarders">Problematic functions generate C forwarders</a></h2>
<p>Where &quot;Problematic&quot; means having a struct as one of its arguments or return type.
In this case we generate several variations of public Scala functions,
but they all delegate to an external C function which takes its arguments as <strong>pointers</strong>, and (optionally) returns its value in a provided heap-allocated location.</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct {
  long long number;
} Small;

void bad_arguments(Small n, Small n2);
Small bad_return_type();
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/419780758753645681header.h
  */
  opaque type Small = CStruct1[CLongLong]
  object Small:
    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]
    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)
    def apply(number : CLongLong)(using Zone): Ptr[Small] = 
      val ____ptr = apply()
      (!____ptr).number = number
      ____ptr
    extension (struct: Small)
      def number : CLongLong = struct._1
      def number_=(value: CLongLong): Unit = !struct.at1 = value


@extern
private[libtest] object extern_functions:
  import _root_.libtest.structs.*
  private[libtest] def __sn_wrap_libtest_bad_arguments(n : Ptr[Small], n2 : Ptr[Small]): Unit = extern

  private[libtest] def __sn_wrap_libtest_bad_return_type(__return : Ptr[Small]): Unit = extern


object functions:
  import _root_.libtest.structs.*
  import extern_functions.*
  export extern_functions.*

  /**
   * [bindgen] header: /tmp/419780758753645681header.h
  */
  def bad_arguments(n : Small, n2 : Small)(using Zone): Unit = 
    val __ptr_0: Ptr[Small] = alloc[Small](2)
    !(__ptr_0 + 0) = n
    !(__ptr_0 + 1) = n2
    __sn_wrap_libtest_bad_arguments((__ptr_0 + 0), (__ptr_0 + 1))

  /**
   * [bindgen] header: /tmp/419780758753645681header.h
  */
  def bad_arguments(n : Ptr[Small], n2 : Ptr[Small]): Unit = 
    __sn_wrap_libtest_bad_arguments(n, n2)

  /**
   * [bindgen] header: /tmp/419780758753645681header.h
  */
  def bad_return_type()(using Zone): Small = 
    val __ptr_0: Ptr[Small] = alloc[Small](1)
    __sn_wrap_libtest_bad_return_type((__ptr_0 + 0))
    !(__ptr_0 + 0)

  /**
   * [bindgen] header: /tmp/419780758753645681header.h
  */
  def bad_return_type()(__return : Ptr[Small]): Unit = 
    __sn_wrap_libtest_bad_return_type(__return)

object types:
  export _root_.libtest.structs.*

object all:
  export _root_.libtest.structs.Small
  export _root_.libtest.functions.bad_arguments
  export _root_.libtest.functions.bad_return_type


</code></pre>
<p><strong>Generated <code>C</code> code</strong></p>
<pre><code class="language-c">#include &lt;string.h&gt;

void __sn_wrap_libtest_bad_arguments(Small *n, Small *n2) {
 bad_arguments(*n, *n2);
};


void __sn_wrap_libtest_bad_return_type(Small *____return) {
  Small ____ret = bad_return_type();
  memcpy(____return, &amp;____ret, sizeof(Small));
}




</code></pre>
</div>
</div>
<h2><a href="#enums-are-generated-for-specific-c-type" id="enums-are-generated-for-specific-c-type">Enums are generated for specific C type</a></h2>
<p>Whatever type clang reports for a particular enum - that's the type that will be
used for the enum.</p>
<p>This is important, as on Windows enums are <code>int</code> by default, whereas on Linux and OS X they are <code>unsigned int</code> (if there's no negative elements).</p>
<p>This documentation is built on Linux.</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef enum {
  U_X = 1,
  U_Y = 4,
  U_Z = 228
} MyUnsigned;

typedef enum {
  X = -1,
  Y = 4,
  Z = 228
} MySigned;
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object predef:
  private[libtest] trait CEnum[T](using eq: T =:= Int):
    given Tag[T] = Tag.Int.asInstanceOf[Tag[T]]
    extension (inline t: T) 
      inline def int: CInt = eq.apply(t)
      inline def value: CInt = eq.apply(t)
  private[libtest] trait CEnumU[T](using eq: T =:= UInt):
    given Tag[T] = Tag.UInt.asInstanceOf[Tag[T]]
    extension (inline t: T)
     inline def int: CInt = eq.apply(t).toInt
     inline def uint: CUnsignedInt = eq.apply(t)
     inline def value: CUnsignedInt = eq.apply(t)


object enumerations:
  import predef.*
  /**
   * [bindgen] header: /tmp/14604838771304578232header.h
  */
  opaque type MySigned = CInt
  object MySigned extends CEnum[MySigned]:
    given _tag: Tag[MySigned] = Tag.Int
    inline def define(inline a: CInt): MySigned = a
    val X = define(-1)
    val Y = define(4)
    val Z = define(228)
    inline def getName(inline value: MySigned): Option[String] =
      inline value match
        case X =&gt; Some(&quot;X&quot;)
        case Y =&gt; Some(&quot;Y&quot;)
        case Z =&gt; Some(&quot;Z&quot;)
        case _ =&gt; _root_.scala.None
    extension (a: MySigned)
      inline def &amp;(b: MySigned): MySigned = a &amp; b
      inline def |(b: MySigned): MySigned = a | b
      inline def is(b: MySigned): Boolean = (a &amp; b) == b

  /**
   * [bindgen] header: /tmp/14604838771304578232header.h
  */
  opaque type MyUnsigned = CUnsignedInt
  object MyUnsigned extends CEnumU[MyUnsigned]:
    given _tag: Tag[MyUnsigned] = Tag.UInt
    inline def define(inline a: Long): MyUnsigned = a.toUInt
    val U_X = define(1)
    val U_Y = define(4)
    val U_Z = define(228)
    inline def getName(inline value: MyUnsigned): Option[String] =
      inline value match
        case U_X =&gt; Some(&quot;U_X&quot;)
        case U_Y =&gt; Some(&quot;U_Y&quot;)
        case U_Z =&gt; Some(&quot;U_Z&quot;)
        case _ =&gt; _root_.scala.None
    extension (a: MyUnsigned)
      inline def &amp;(b: MyUnsigned): MyUnsigned = a &amp; b
      inline def |(b: MyUnsigned): MyUnsigned = a | b
      inline def is(b: MyUnsigned): Boolean = (a &amp; b) == b

object types:
  export _root_.libtest.enumerations.*

object all:
  export _root_.libtest.enumerations.MySigned
  export _root_.libtest.enumerations.MyUnsigned


</code></pre>
</div>
</div>
<h2><a href="#function-pointers-are-defined-as-opaque-types" id="function-pointers-are-defined-as-opaque-types">Function pointers are defined as opaque types</a></h2>
<p>The inlining in <code>apply</code> method is important - it's a restricting of Scala Native
that the function must be statically known.</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef void* Cursor;
typedef int (*Visitor)(Cursor*);
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object aliases:
  import _root_.libtest.aliases.*
  /**
   * [bindgen] header: /tmp/10474238745347693661header.h
  */
  opaque type Cursor = Ptr[Byte]
  object Cursor: 
    given _tag: Tag[Cursor] = Tag.Ptr(Tag.Byte)
    inline def apply(inline o: Ptr[Byte]): Cursor = o
    extension (v: Cursor)
      inline def value: Ptr[Byte] = v

  /**
   * [bindgen] header: /tmp/10474238745347693661header.h
  */
  opaque type Visitor = CFuncPtr1[Ptr[Cursor], CInt]
  object Visitor: 
    given _tag: Tag[Visitor] = Tag.materializeCFuncPtr1[Ptr[Cursor], CInt]
    inline def fromPtr(ptr: Ptr[Byte] | Ptr[?]): Visitor = CFuncPtr.fromPtr(ptr.asInstanceOf[Ptr[Byte]])
    inline def apply(inline o: CFuncPtr1[Ptr[Cursor], CInt]): Visitor = o
    extension (v: Visitor)
      inline def value: CFuncPtr1[Ptr[Cursor], CInt] = v
      inline def toPtr: Ptr[?] = CFuncPtr.toPtr(v)

object types:
  export _root_.libtest.aliases.*

object all:
  export _root_.libtest.aliases.Cursor
  export _root_.libtest.aliases.Visitor


</code></pre>
</div>
</div>
<h2><a href="#recursive-structs-are-rewritten-with-opaque-pointers" id="recursive-structs-are-rewritten-with-opaque-pointers">Recursive structs are rewritten with opaque pointers</a></h2>
<p>This is invisible to the user, so doesn't impact the experience, but
can complicate reading the code.</p>
<p>Scala cannot have recursive type aliases.</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct Arr;

typedef struct {
  struct Arr* nested;
} Arr;
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/10932974961499589141header.h
  */
  opaque type Arr = CStruct1[Ptr[Byte]]
  object Arr:
    given _tag: Tag[Arr] = Tag.materializeCStruct1Tag[Ptr[Byte]]
    def apply()(using Zone): Ptr[Arr] = scala.scalanative.unsafe.alloc[Arr](1)
    def apply(nested : Ptr[Arr])(using Zone): Ptr[Arr] = 
      val ____ptr = apply()
      (!____ptr).nested = nested
      ____ptr
    extension (struct: Arr)
      def nested : Ptr[Arr] = struct._1.asInstanceOf[Ptr[Arr]]
      def nested_=(value: Ptr[Arr]): Unit = !struct.at1 = value.asInstanceOf[Ptr[Byte]]

object types:
  export _root_.libtest.structs.*

object all:
  export _root_.libtest.structs.Arr


</code></pre>
</div>
</div>
<h2><a href="#global-enums-are-rendered-as-constants" id="global-enums-are-rendered-as-constants">Global enums are rendered as constants</a></h2>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">enum {
  HELLO = 25,
  BYEBYE = 11
};

enum {
  HOW=-1,
  DOESTHIS=-2,
  WORK=0
};
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object constants:
  val HELLO: CUnsignedInt = 25.toUInt
  val BYEBYE: CUnsignedInt = 11.toUInt
  
  val HOW: CInt = -1
  val DOESTHIS: CInt = -2
  val WORK: CInt = 0
  


</code></pre>
</div>
</div>
</div></article></main><footer class="text-center m-4 p-4 text-lg text-white font-bold m-auto w-full">© 2021-2024 Anton Sviridov</footer><script src="https://www.googletagmanager.com/gtag/js?id=G-2V7BY56Z37"></script><script> window.dataLayer = window.dataLayer || [];
              function gtag(){window.dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-2V7BY56Z37');</script></body></html>