<html><head><title>SN bindgen: Exports </title><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/tomorrow-night-blue.min.css" /><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/scala.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/c.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="/assets/styles.css" /><link rel="stylesheet" href="/assets/tailwind.css" /><script src="/assets/search.js" defer="defer"></script><script src="/assets/search-index.js" defer="defer"></script><link rel="stylesheet" href="/assets/subatomic-search.css" /><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /></head><body onclick="SubatomicSearchFrontend.sayHello()" class="bg-gradient-to-r from-emerald-800 to-sky-700 mt-4 w-full"><header class="flex m-2 mb-4 md:m-auto md:w-11/12 lg:max-w-7xl flex-col md:flex-row md:items-center justify-between mb-2"><div><a class="block text-6xl text-white" href="/">SN bindgen</a><p class="text-white">Scala 3 Native binding generator to C libraries</p></div><div id="searchContainer"></div><div class="site-links"><a href="https://github.com/indoorvivants/sn-bindgen"><img class="w-12 opacity-70 hover:opacity-100" src="https://cdn.svgporn.com/logos/github-icon.svg" /></a></div></header><main class="rounded-xl bg-white m-2 mb-4 md:m-auto md:w-11/12 lg:max-w-7xl p-4 flex flex-col-reverse md:flex-row gap-6"><aside class="lg:w-64 shrink-1 lg:shrink-0 grow-0 md:border-r-2 max-w-[300px] border-slate-200 pr-2"><ul class="text-2xl p-4 block"><li><a class="" href="/index.html">Home</a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/limitations/index.html">Limitations</a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/configuration/index.html">Configuration </a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/cookbook/index.html">Cookbook</a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/quickstart/index.html">Quick start</a><ul class="text-xl p-2 block"></ul></li><li><a class="font-bold" href="/exports/index.html">Exports </a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/semantics/index.html">Semantics </a><ul class="text-xl p-2 block"></ul></li><li><a class="" href="/motivation/index.html">Motivation</a><ul class="text-xl p-2 block"></ul></li></ul></aside><article class="grow-4 lg:max-w-6xl markdown"><div class="float-right p-3 rounded-md border-2 border-sky-700 max-w-12 m-4"><ul class="list-disc my-0 mx-2 text-sm"><li><a class="underline hover:no-underline text-sky-700 text-base" href="#exporting-binary-interface-to-scala-native-code">Exporting binary interface to Scala Native code</a></li><li><a class="underline hover:no-underline text-sky-700 text-base" href="#on-static-libraries-and-scalanativeinit">On static libraries and `ScalaNativeInit`</a></li></ul></div><div><h2><a href="#exporting-binary-interface-to-scala-native-code" id="exporting-binary-interface-to-scala-native-code">Exporting binary interface to Scala Native code</a></h2>
<p>You can use bindgen not only to interface with C libraries,
but also to define the C-compatible interface of a Scala Native
project built as a dynamic or shared library.</p>
<p>Scala Native itself supports it via <a href="https://scala-native.org/en/stable/user/interop.html#exported-methods"><code>@exported</code> family of annotations</a>.</p>
<p>Say you want to expose your Scala Native code as a dynamic/shared
library. You could manually define your functions like this:</p>
<pre><code class="language-scala">import scalanative.unsafe.*

@exported
def MYLIB_func1(): CString = c&quot;hello!&quot;

@exported
def MYLIB_func2(i: Int, b: Long): Long = i * b
</code></pre>
<p>And for a simple interface with primitive types that's exactly what
we recommend doing.</p>
<p>But what if your functions are more complex? They could involve structs, enums, and more complex C types than just primitives. Especially if your target runtime supports complex C types - like Swift, for example, that can work directly with header files and handle lots of different C types.</p>
<p>In this case, Bindgen supports a special export mode, which will do the
following, assuming you generate bindings in package <code>libtest</code>:</p>
<ol>
<li>Generate a regular Scala trait <code>libtest.ExportedFunctions</code> which will
contain all the functions from the header file</li>
<li>Generate a <code>libtest.functions</code> object that extends <code>libtest.ExportedFunctions</code>, where each function is given a body, which invokes <code>libtest.impl.Implementations.&lt;funcName&gt;</code> - where <code>libtest.impl.Implementations</code> <em>also</em> extends <code>libtest.ExportedFunctions</code> - that's where you can define implementations for your functions.</li>
</ol>
<ul>
<li>
<p>In CLI, this mode can be activated by using the <code>--export</code> flag</p>
</li>
<li>
<p>In SBT, you can enable it by using <code>.withExport(true)</code> on the Binding builder:
<code>Binding.builder(&lt;headerFile&gt;, &lt;packageName&gt;).withExport(true).build</code></p>
</li>
</ul>
<p>If this sounds confusing, let's take a look at a very simple example, where the interface doesn't use anything other than primitive types:</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">long myThing(int n, long i);
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">TypeImports(enums = false, aliases = false, structs = false, unions = false)
package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

trait ExportedFunctions:
  /**
   * [bindgen] header: /tmp/3278843238391930171header.h
  */
  def myThing(n : CInt, i : CLongInt): CLongInt


object functions extends ExportedFunctions:
  /**
   * [bindgen] header: /tmp/3278843238391930171header.h
  */
  @exported
  override def myThing(n : CInt, i : CLongInt): CLongInt = libtest.impl.Implementations.myThing(n, i)


</code></pre>
<p><strong>Generated <code>C</code> code</strong></p>
<pre><code class="language-c">TypeImports(enums = false, aliases = false, structs = false, unions = false)

</code></pre>
</div>
</div>
<p>If you attempt to compile the generated Scala code as is, it won't work - because you need to provide implementations.</p>
<p>The reason implementations are expected in a separate file is to allow you to edit the header file (which defines your binary interface) separately from implementations. And the <code>ExportedFunctions</code> trait
exists to assist in defining said implementations - making it IDE friendly.</p>
<p>Here's an example of how you can define <code>Implementations</code>:</p>
<pre><code class="language-scala">package libtest.impl 

import libtest.all.*

object Implementations extends libtest.ExportedFunctions:
  override def myThing(n: Int, i: Long): Long = 
    n * i
</code></pre>
<p>Now that you saw this trivial example, here's a more complex one, which uses structs. Usual restrictions
still apply - structs have to be received by address (<code>param: Ptr[MyStruct]</code>), not by value (<code>param: MyStruct</code>):</p>
<div class = "flex-col w-full gap-4">
<div class = "w-12/12">
<p><strong>Source <code>C</code> code</strong></p>
<pre><code class="language-c">typedef struct {
  int length;
  const char *str;
} MyStuff;

long myThing(int n, const MyStuff* str);
</code></pre>
</div>
<div class = "w-12/12">
<p><strong>Generated <code>Scala</code> code</strong></p>
<pre><code class="language-scala">TypeImports(enums = false, aliases = false, structs = true, unions = false)
package libtest

import _root_.scala.scalanative.unsafe.*
import _root_.scala.scalanative.unsigned.*
import _root_.scala.scalanative.libc.*
import _root_.scala.scalanative.*

object structs:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/7633895452064626108header.h
  */
  opaque type MyStuff = CStruct2[CInt, CString]
  object MyStuff:
    given _tag: Tag[MyStuff] = Tag.materializeCStruct2Tag[CInt, CString]
    def apply()(using Zone): Ptr[MyStuff] = scala.scalanative.unsafe.alloc[MyStuff](1)
    def apply(length : CInt, str : CString)(using Zone): Ptr[MyStuff] = 
      val ____ptr = apply()
      (!____ptr).length = length
      (!____ptr).str = str
      ____ptr
    extension (struct: MyStuff)
      def length : CInt = struct._1
      def length_=(value: CInt): Unit = !struct.at1 = value
      def str : CString = struct._2
      def str_=(value: CString): Unit = !struct.at2 = value

trait ExportedFunctions:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/7633895452064626108header.h
  */
  def myThing(n : CInt, str : Ptr[MyStuff]): CLongInt


object functions extends ExportedFunctions:
  import _root_.libtest.structs.*
  /**
   * [bindgen] header: /tmp/7633895452064626108header.h
  */
  @exported
  override def myThing(n : CInt, str : Ptr[MyStuff]): CLongInt = libtest.impl.Implementations.myThing(n, str)

object types:
  export _root_.libtest.structs.*

object all:
  export _root_.libtest.structs.MyStuff

</code></pre>
<p><strong>Generated <code>C</code> code</strong></p>
<pre><code class="language-c">TypeImports(enums = false, aliases = false, structs = true, unions = false)

</code></pre>
</div>
</div>
<h2><a href="#on-static-libraries-and-scalanativeinit" id="on-static-libraries-and-scalanativeinit">On static libraries and <code>ScalaNativeInit</code></a></h2>
<p>If you read <a href="https://scala-native.org/en/stable/user/interop.html#exported-methods">the section about native exports</a>, you can see a reminder to call <code>ScalaNativeInit()</code> function to
initialise the Scala Native GC runtime.</p>
<p>Therefore if you are interacting with an ecosystem that handles C header files natively (like Swift),
it's convenient to put <code>ScalaNativeInit</code> into the header file that defines your binary interface.</p>
<p>Bindgen recognises that and doesn't render this function as part of the bindings.
The function has to exactly match the <code>int ScalaNativeInit(void)</code> type to be filtered out.</p>
</div></article></main><footer class="text-center m-4 p-4 text-lg text-white font-bold m-auto w-full">© 2021-2023 Anton Sviridov</footer><script src="https://www.googletagmanager.com/gtag/js?id=G-2V7BY56Z37"></script><script> window.dataLayer = window.dataLayer || [];
              function gtag(){window.dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-2V7BY56Z37');</script></body></html>