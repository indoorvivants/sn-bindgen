<html><head><title>SN bindgen: Motivation</title><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/androidstudio.min.css" /><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/languages/scala.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/languages/c.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="/assets/styles.css" /><link rel="stylesheet" href="/assets/template.css" /><script src="/assets/search.js"></script><script src="/assets/search-index.js"></script><link rel="stylesheet" href="/assets/subatomic-search.css" /><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /></head><body><div class="container"><header class="main-header"><div class="site-title"><h1><a href="/">SN bindgen</a></h1><small>Scala 3 Native binding generator to C libraries</small></div><div id="searchContainer" class="searchContainer"></div><div class="site-links"><a href="https://github.com/indoorvivants/sn-bindgen"><img src="https://cdn.svgporn.com/logos/github-icon.svg" class="gh-logo" /></a></div></header><div><a class="nav-btn" href="/index.html">Home</a><a class="nav-btn" href="/cookbook/index.html">Cookbook</a><a class="nav-btn" href="/semantics/index.html">Semantics </a><a class="nav-btn nav-selected" href="/motivation/index.html">Motivation</a><a class="nav-btn" href="/limitations/index.html">Limitations</a><a class="nav-btn" href="/configuration/index.html">Configuration </a><a class="nav-btn" href="/quickstart/index.html">Quick start</a></div><hr /><div><p>As an offering, Scala Native is in an interesting place.</p>
<p>On the one hand, it can leverage the power of LLVM, a huge project, with literal
<em>thousands</em> of contributors.</p>
<p>On the other, it has to find a place among the many new (-ish) languages, designed
from scratch to compile to machine code, with memory and execution semantics
tailored to fit this type of execution.</p>
<p>Scala Native, therefore, is most attractive to developers already familiar
with Scala, and interested in exploring the unfamiliar (after JVM) world of
native code, dynamic and static libraries etc.</p>
<p>Additionally, competing with the absolutely enormous ecosystem of JVM libraries,
both written in Java and Scala, is hard.</p>
<p>What is also important to recognise is that (rightly or wrongly, I can't say), C
emerged as the lingua franca for definition of binary interfaces.</p>
<p>Languages like <a href="https://ziglearn.org/chapter-4/#abi">Zig</a>, <a href="https://doc.rust-lang.org/std/keyword.extern.html">Rust</a>, <a href="https://pkg.go.dev/cmd/cgo#hdr-Go_references_to_C">Go</a> have ways of calling external C code. Doing so requires
careful consideration with regards to the memory layout of arguments, their sizes, their positions, etc. so that an external function written in C, for example, can be invoked correctly.</p>
<p>It was therefore important for me to explore the ability of writing idiomatic Scala 3
code designed to leverage the power of existing C libraries, or C interfaces to
libraries in other languages.</p>
<hr />
<p><em>This is the beginning of opinions, bias all over the place</em></p>
<hr />
<h2><a href="#short-history" id="short-history">Short history</a></h2>
<p>I was acutely aware of the existing <a href="https://github.com/scala-native/scala-native-bindgen/">Scala 2 binding generator</a>. At one point I started to dig into it to help
move it to Scala Native 0.4.x. What I quickly realised is that I struggle to write
C++ code. And because of interaction with the compiler frontend, C++ code is almost half of the bindgen project.</p>
<p>So this project started as an experiment with two main goals:</p>
<ol>
<li>
<p>Leveraging Scala 3 features as much as possible</p>
<p>Things like opaque types, strict inlining, and extension methods
are absolutely paramount to the compiletime safety of generated code
and runtime performance.</p>
<p>See <a href="#why-scala-3">below</a></p>
</li>
<li>
<p>Minimising the amount of non-Scala code in project</p>
<p>I am willing to bet that people who will try out Scala Native won't be
seasoned C++ programmers (in their absolute majority), and therefore
will be more comfortable with Scala - sticking to it should minimise the
barrier of entry to contributors, which can ensure project's sustainability.</p>
<p>Also, I can't write C++ or C, so there's that also.</p>
</li>
</ol>
<p>After the initial bootstrapped binding to libclang showed me how the generated code
could look like, I continued to experiment with the C's AST, eventually arriving at a
half-baked generator with no tests that was held together by prayers alone.</p>
<p>What spurred me into action was figuring out (staring a lot at <a href="https://github.com/thesamet/sbt-protoc">sbt-protoc</a> helped) how to publish platform-specific binaries and
resolve them using coursier alone - after that the generation process started taking shape.</p>
<h4><a href="#why-scala-3" id="why-scala-3">Why Scala 3?</a></h4>
<p>At the time of writing, Scala Native is at version 0.4.4. While the ecosystem
of cross-built libraries is growing, the real-world usage remains low - which is perfectly understandable for a project so recently revived.</p>
<p>Multi-threading will arrive in 0.5.x, and 1.0.x is not planned yet.
All this to say that Scala Native is a very, very exciting project in its early
days, if it proves its feasibility, it is a player in the market of the near future.</p>
<p>So is Scala 3. The amount of improvements and new features compared to Scala 2 is hard to overestimate - and it will take some time for those features to be
proved out in the wild, and polished enough for widespread usage.</p>
<p>As such, I believe that Scala Native + Scala 3 is a very powerful combination, one that
takes the experimental nature of both, and even right now provides a solid foundation for
experiments and even user facing application.</p>
<p>So keeping the code generator focused on Scala 3, we can better shape the near future where
(hopefully) this combination will become at least as popular as Scala.js.</p>
<p>That said, it's not a hill I will die on. It's just Scala 2 frontend is not something I will
actively pursue - there's plenty of my own stupid bugs to keep me busy.</p>
</div></div><footer>Â© 2021-2023 Anton Sviridov</footer><script src="https://www.googletagmanager.com/gtag/js?id=G-2V7BY56Z37"></script><script> window.dataLayer = window.dataLayer || [];
              function gtag(){window.dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-2V7BY56Z37');</script></body></html>